This thesis falls into the category of cognitive architectures and the integrated approach to AI, pioneered by people like Rodney Brooks and his subsumption architecture, and \cite{brooksSubsumption}, Douglas Hofstaedter, who famously wrote about many aspects of AI in GÃ¶del, Escher, Bach \cite{geb}, and who created the Copycat analogy-making program \cite{copycat}. 

\todo{cite others} \todo{describe their work: HCS, nouvelle AI?, 4catr, etc. - 1-2 paragraphs}.

The probably earliest example of a cognitive architecture was Allen Newell's and Herbert~A.~Simon's {\em Logic Theorist}, created in 1955 \todo{cite logic theorist}. Simon's theory of bounded rationality \cite{Gigerenzer2001} --- the idea of finding a merely satisfactory solution instead of a (provably) optimal one --- is very similar to the loop between belief generation and evaluation described in Section~\ref{sec:implementation}. In both cases, agents with limited information search heuristically for the first solution that they find acceptable. Unlike exhaustive search methods (e.g. A*), this does not guarantee the best possible results, but it is much more cost-effective and closer to the way real humans solve problems. In spirit, this is also similar to the {\em Procedural Reasoning System} of Michael Georgeff et al. \cite{pcs}, which is based on the belief-desire-intention model \cite{Rao95bdiagents, Bratman87}. Much theoretical work has been done on BDI, but it is only tangentially related to this thesis.\\

In terms of software engineering, our model has similarities, both to the Actor model, and to publish/subscribe architectures \todo{cite} --- although more as a concession to practicality and less because of a similarity to their theories. The theoretical basis of our implementation is the postulate that the components of the brain function as white boxes and that other components may listen in on their activity, so to speak. Since this is diametrically opposed to the traditional idea of the procedure/function as a black box, which nigh every programming language follows, we compromise and model the cognitive structure as a mesh of loosely coupled components communicating via passing. This description is reminiscent to the Actor model developed by Carl Hewitt et al. \cite{hewittActor}, although there are differences\footnote{Although I do not describe the implementation in the language of the Actor model, a translation into it would be quite easy. Such a translation would require using only very rudimentary features of the model, however, and as that is not the focus, I forego the task.}: in the Actor model, the topology of the network may change through the creation of new actors, and messages are always passed from one source to known targets (via addresses). In our model, on the other hand, there is no topology in a strict sense; messages are put into a global message storage and every component is free to consume any message it deems relevant. Senders do not know who will read their output, and consumers do not know the sources. This arrangement can be seen as a particularly loose variant of a publish/subscribe architecture, in which the source and the target of a message are completely unaware of each other, and in which there are no specific channels to which one may subscribe. The only criterion by which messages may be accepted or rejected is their content.

We also make use of already existing solutions --- specifically answer-set programming and the \acthex\ solver \dlvhex. The internal world simulation of our agents makes use of the non-monotonic reasoning provided by ASP and \acthex.  Answer-set programming was created by Gelfond and Lifschitz \cite{asp1}. Soon after them, Subrahmanian made the connection between ASP and planning \cite{Subrahmanian95relatingstable}. Together with Eiter and others, he later developed the \acthex\ language which allowed provided a framework for decision making in logic programming via external input and output atoms \cite{heterogeneous1, heterogeneous2, heterogeneous3}.